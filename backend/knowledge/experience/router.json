[
  {
    "q": "[Graphviz DOT] Large scale microservices architecture with many nodes and complex dependencies",
    "a": "For diagrams involving large-scale architectures, extensive node connections, or where precise automatic layout is critical, use Graphviz (DOT). Its 'dot' engine excels at handling complex topologies, minimizing edge crossings, and maintaining a clean, hierarchical structure automatically, making it the ideal choice for massive or intricate graphs.",
    "source_code": "digraph Microservices {\n    rankdir=LR;\n    node [shape=box, style=filled, fillcolor=lightblue];\n    \n    subgraph cluster_backend {\n        label=\"Backend Core\";\n        style=dashed;\n        API_Gateway -> Auth_Service;\n        API_Gateway -> Order_Service;\n        Order_Service -> Payment_Service;\n        Order_Service -> Inventory_Service;\n        Inventory_Service -> DB_Primary;\n    }\n    \n    Client_App -> API_Gateway;\n    Admin_Portal -> API_Gateway;\n}"
  },
  {
    "q": "[Mermaid Flowchart] Simple user login logic and error handling",
    "a": "For simple logic flows with a small number of nodes (less than 10), Mermaid Flowchart is the best choice. It is lightweight, renders natively in most web environments, and efficiently represents standard decision trees using 'graph TD' (Top-Down).",
    "source_code": "graph TD\n    A[User Input] --> B{Valid Format?}\n    B -- No --> C[Show Error]\n    B -- Yes --> D{Check DB}\n    D -- Found --> E[Login Success]\n    D -- Not Found --> F[Login Failed]"
  },
  {
    "q": "[Mermaid Sequence] OAuth2 token exchange process between client and server",
    "a": "When the goal is to visualize interactions, message exchanges, or protocol handshakes over time between specific participants, strictly select 'sequenceDiagram'. It explicitly maps out the temporal order of events, which is difficult to convey in a standard flowchart.",
    "source_code": "sequenceDiagram\n    participant User\n    participant App\n    participant AuthServer\n    User->>App: Click Login\n    App->>AuthServer: Request Auth Code\n    AuthServer-->>User: Prompt Credentials\n    User->>AuthServer: Submit Credentials\n    AuthServer-->>App: Return Code"
  },
  {
    "q": "[Mermaid Gantt] Project development timeline and roadmap",
    "a": "If the query involves schedules, dates, project phases, durations, or roadmaps, strictly use 'gantt'. This diagram type is specifically designed to handle time-based dependencies and visualizes the project timeline effectively.",
    "source_code": "gantt\n    title Q4 Roadmap\n    dateFormat  YYYY-MM-DD\n    section Development\n    Backend API      :active, a1, 2023-10-01, 30d\n    Frontend UI      :after a1, 20d\n    section Testing\n    Integration Test :2023-11-15, 10d"
  },
  {
    "q": "[Mermaid Class] Object-oriented structure of a shopping cart system",
    "a": "For representing static code structures, class hierarchies, interfaces, and relationships like inheritance or aggregation, use 'classDiagram'. It provides standard UML syntax that is far more semantically accurate for software modeling than generic graphs.",
    "source_code": "classDiagram\n    class Cart {\n        +List items\n        +checkout()\n    }\n    class Item {\n        +int id\n        +float price\n    }\n    Cart \"1\" *-- \"*\" Item : contains"
  },
  {
    "q": "[Graphviz DOT] Circular dependencies analysis in module imports",
    "a": "Graphviz is highly effective for visualizing circular dependencies or non-hierarchical network structures. By using layout engines like 'circo' or 'neato', it can automatically arrange nodes to highlight clusters and cycles without the layout constraints typical of directed flowcharts.",
    "source_code": "digraph Dependencies {\n    layout=circo;\n    ModuleA -> ModuleB;\n    ModuleB -> ModuleC;\n    ModuleC -> ModuleA;\n    ModuleC -> ModuleD;\n}"
  },
  {
    "q": "[Mermaid State] Order lifecycle status transition",
    "a": "Focus on the 'status' or 'state' of a single entity (e.g., Pending -> Shipped -> Delivered) rather than a process flow. Use 'stateDiagram-v2' for these finite state machines to clearly depict transitions, triggers, and state persistence.",
    "source_code": "stateDiagram-v2\n    [*] --> Pending\n    Pending --> Processed : Payment OK\n    Processed --> Shipped : Dispatched\n    Shipped --> [*]"
  },
  {
    "q": "[Mermaid ER] Blog system database schema and entity relationships",
    "a": "When the request involves database tables, foreign keys, or entity relationships (One-to-Many, etc.), use 'erDiagram'. It is purpose-built to visualize data schemas and cardinality concisely.",
    "source_code": "erDiagram\n    USER ||--o{ POST : writes\n    POST ||--|{ COMMENT : has\n    USER {\n        string username\n        string email\n    }\n    POST {\n        string title\n        text content\n    }"
  }
]